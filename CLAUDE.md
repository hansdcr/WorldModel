# 世界模型学习项目 - Claude AI 协作规范

> **目的**: 本文档定义了 Claude AI 在协助本项目学习过程中必须遵守的规则和标准
> **适用对象**: Claude AI（你）
> **最后更新**: 2025-11-21

---

## 🎯 项目核心目标

**学习者背景**:
- Python 初级开发者
- 文科背景，高中数学基础（已多年未使用）
- 从零开始学习世界模型原理

**最终目标**:
构建能够生成室内装修设计 XR/MR/AR 环境的世界模型系统，具备：
- 可控生成室内家具（如客厅沙发）
- 参数化控制（大小、颜色、样式）
- 场景融合（自然融入环境）
- XR 环境适配

**技术标杆**: World Labs Marble

---

## 🐍 Python 虚拟环境要求（强制）

### 0.1 虚拟环境配置

**RULE 0: 强制使用虚拟环境**

```
✅ 项目已配置:
  - Python 版本: 3.12.3
  - 虚拟环境路径: /Users/gelin/Desktop/store/dev/python/3.10/WorldModel/venv
  - 已安装基础依赖: numpy, matplotlib, opencv-python, pillow, tqdm, jupyter

❌ 绝对禁止:
  - 在系统 Python 中安装依赖
  - 使用其他 Python 版本
  - 不激活虚拟环境就运行代码
```

### 0.2 每次运行代码的标准流程

**RULE 0.1: 代码执行前必须激活虚拟环境**

```bash
# 标准执行流程（每次必须）:
cd /Users/gelin/Desktop/store/dev/python/3.10/WorldModel
source venv/bin/activate  # macOS/Linux
# 或
venv\Scripts\activate     # Windows

# 然后执行代码
python code/iteration_XX/filename.py
```

**RULE 0.2: 安装新依赖时的流程**

```bash
# 1. 激活虚拟环境
source venv/bin/activate

# 2. 安装依赖
pip install package_name

# 3. 更新 requirements.txt（如果是新依赖）
pip freeze > requirements.txt
```

### 0.3 虚拟环境验证

**RULE 0.3: 每次协助时先验证环境**

Claude AI 在运行代码前必须：
1. 确认虚拟环境已激活
2. 使用 `source venv/bin/activate &&` 前缀执行命令
3. 验证 Python 版本是 3.12.x

**验证命令**:
```bash
source venv/bin/activate && python --version
# 预期输出: Python 3.12.3
```

### 0.4 便捷脚本

项目提供以下便捷脚本：
- `activate_env.sh` - 快速激活虚拟环境
- `run_iteration.sh` - 运行指定迭代的代码

**使用方式**:
```bash
# 激活环境
source activate_env.sh

# 运行迭代1
./run_iteration.sh 1
```

---

## 📋 必须遵守的核心原则

### 1. 学习方式原则

#### 1.1 从零构建，不走捷径
```
✅ DO: 从原理出发，逐步构建理解
✅ DO: 引导学习者自己动手编写代码
✅ DO: 解释"为什么"而不只是"怎么做"

❌ DON'T: 直接提供完整的开源模型使用方案
❌ DON'T: 建议"直接用某个库就行"
❌ DON'T: 跳过基础原理讲解
```

#### 1.2 渐进式学习
```
✅ DO: 每次只聚焦一个核心知识点
✅ DO: 确保当前迭代建立在前序迭代基础上
✅ DO: 小步快跑，频繁验证理解

❌ DON'T: 一次讲太多概念
❌ DON'T: 跳跃式教学
❌ DON'T: 假设学习者已经掌握某些知识
```

#### 1.3 原理驱动
```
✅ DO: 深入讲解技术背后的数学和物理原理
✅ DO: 用高中数学知识解释（优先）
✅ DO: 提供可视化辅助理解
✅ DO: 对比不同技术方案的优劣

❌ DON'T: 只讲 API 使用
❌ DON'T: 直接给高等数学公式不解释
❌ DON'T: 假设学习者理解术语
```

#### 1.4 实践导向
```
✅ DO: 每个迭代都要有可运行的代码
✅ DO: 代码要产生可见的结果（可视化/输出）
✅ DO: 鼓励学习者修改参数实验

❌ DON'T: 只讲理论不写代码
❌ DON'T: 代码无法独立运行
❌ DON'T: 结果不可视化
```

---

## 📐 迭代划分与执行规则

### 2.1 迭代粒度控制

**每个迭代必须满足**:
1. **单一知识点**: 只专注一个核心概念/技术
2. **1-2 天完成**: 每天 2-3 小时学习强度
3. **逻辑递进**: 依赖前序迭代，为后续铺垫
4. **可理解性**: 初学者能够理解（高中数学基础）
5. **可验证性**: 有明确的完成标准和输出

**错误示例**:
```
❌ 迭代X: 学习 Transformer + CLIP + 多模态融合
   → 太多概念，应拆分为 3 个迭代
```

**正确示例**:
```
✅ 迭代7: Transformer 基础（Self-Attention）
✅ 迭代8: Vision Transformer（图像分块）
✅ 迭代9: CLIP（文本-图像对齐）
```

### 2.2 迭代命名规范

```
格式: 迭代 X: 核心概念 - 简短描述

✅ 好的命名:
  - 迭代 1: 什么是空间智能？
  - 迭代 16: 3D 高斯泼溅 - Part 1
  - 迭代 32: 结构-风格解耦 (Chisel 模式)

❌ 不好的命名:
  - 迭代 X: 学习一些东西
  - 迭代 X: 高级技术
  - 迭代 X: 继续上次的内容
```

---

## 💻 代码规范要求（严格执行）

### 3.1 文件组织规则

**RULE 1: 单文件原则**
```
每个迭代生成 ≤ 1 个主要代码文件

✅ 允许:
  code/iteration_01/spatial_concept.py  (主文件)
  code/iteration_01/utils.py           (辅助工具，可选)

❌ 禁止:
  code/iteration_01/file1.py
  code/iteration_01/file2.py
  code/iteration_01/file3.py
  → 说明迭代粒度太大，应拆分
```

**RULE 2: 单方法原则**
```
每次生成代码时，每个文件最多新增 1 个主要方法/函数

例外: 辅助的小函数（≤10 行）可以多个
```

**RULE 3: 代码行数限制**
```python
# 每个方法最多 50 行代码

✅ 好的示例:
def visualize_3d_point(point, label):
    """可视化一个 3D 点 (共 30 行)"""
    # ... 实现逻辑
    pass

❌ 错误示例:
def complex_function():
    """一个 150 行的函数"""
    # ... 太长了！
    pass

# 正确做法: 拆分成多个小函数
def complex_function():
    """主函数 (20 行)"""
    data = load_data()
    processed = process_data(data)
    visualize_result(processed)

def load_data():
    """加载数据 (15 行)"""
    pass

def process_data(data):
    """处理数据 (25 行)"""
    pass

def visualize_result(result):
    """可视化 (30 行)"""
    pass
```

**RULE 4: 方法自动拆分**
```
如果一个方法超过 50 行，必须拆分成多个小方法

拆分策略:
1. 按功能模块拆分
2. 提取重复逻辑
3. 分离配置与执行
4. 独立可视化部分
```

### 3.2 代码质量要求

**RULE 5: 可读性优先**
```python
# ✅ 好的代码: 清晰、有注释、变量名语义化
def calculate_distance(point1, point2):
    """
    计算两个 3D 点之间的欧氏距离

    Args:
        point1: np.array([x, y, z])
        point2: np.array([x, y, z])

    Returns:
        float: 欧氏距离
    """
    # 计算差值向量
    diff = point1 - point2

    # 计算向量的模（L2 范数）
    distance = np.linalg.norm(diff)

    return distance

# ❌ 不好的代码: 变量名不清晰，无注释
def calc(p1, p2):
    d = p1 - p2
    return np.linalg.norm(d)
```

**RULE 6: 注释规范**
```python
# 必须包含的注释:
1. 文件头部的模块说明
2. 每个函数的 docstring（包含参数、返回值、功能说明）
3. 关键逻辑点的行内注释
4. 复杂算法的步骤说明

# 示例:
"""
迭代 X - 文件名: 功能描述

学习目标:
- 目标 1
- 目标 2

运行方法:
    python filename.py
"""

import numpy as np


def main_function(param1, param2):
    """
    函数的简短描述

    详细说明函数的功能和用途

    Args:
        param1: 参数 1 的说明
        param2: 参数 2 的说明

    Returns:
        返回值的说明
    """
    # 步骤 1: 数据准备
    data = prepare_data(param1)

    # 步骤 2: 核心计算
    result = compute(data, param2)

    # 步骤 3: 结果处理
    return process_result(result)
```

**RULE 7: 模块化设计**
```python
# ✅ 好的设计: 功能解耦，易于扩展
class WorldState:
    def __init__(self):
        self.objects = []

    def add_object(self, obj):
        """添加物体"""
        pass

    def remove_object(self, obj):
        """移除物体"""
        pass

    def find_nearest(self, obj):
        """找最近的物体"""
        pass

# ❌ 不好的设计: 所有功能堆在一个函数里
def do_everything():
    # 200 行代码做所有事情
    pass
```

**RULE 7.5: 中文字体配置（强制）**

**所有使用 matplotlib 进行可视化的代码文件，必须配置中文字体支持，避免中文显示为方框。**

```python
# 必须在文件开头添加（导入语句后）:

import sys
sys.path.insert(0, '/Users/gelin/Desktop/store/dev/python/3.10/WorldModel')

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from utils.matplotlib_config import setup_chinese_font

# 配置中文字体支持（自动检测操作系统）
setup_chinese_font(verbose=False)


# 之后的代码可以正常使用中文
def visualize_data():
    plt.title('中文标题')  # ✅ 中文正常显示
    plt.xlabel('X 轴（米）')
    # ...
```

**为什么需要这个规则？**
- matplotlib 默认使用 DejaVu Sans 字体，不包含中文字符
- 不配置会导致中文显示为方框（□□□），影响学习体验
- `utils/matplotlib_config.py` 自动检测操作系统并选择合适字体：
  - macOS: Arial Unicode MS
  - Windows: SimHei / Microsoft YaHei
  - Linux: WenQuanYi Micro Hei

**强制要求**:
```
✅ DO: 所有使用 plt.xlabel/ylabel/title 等中文的文件必须引入
✅ DO: 在任何绘图代码前调用 setup_chinese_font()
✅ DO: 使用 verbose=False 避免重复输出配置信息

❌ DON'T: 跳过字体配置直接使用中文
❌ DON'T: 手动配置字体（应使用统一工具模块）
❌ DON'T: 忽略字体警告
```

---

## 📝 文档规范要求

### 4.1 文档类型与命名

**RULE 8: 文档类型严格区分**

| 文档类型 | 命名规则 | 何时创建 | 内容要求 |
|---------|---------|---------|---------|
| **迭代说明** | `code/iteration_XX/README.md` | 每个迭代必须 | 目标、原理、代码、思考题 |
| **知识总结** | `docs/迭代X-总结.md` | 每个迭代必须 | 核心知识点、代码总结、收获 |
| **代码修复** | `docs/迭代X-修复.md` | 发现 bug 时 | 问题、原因、修复、经验 |
| **扩展知识** | `docs/迭代X-扩展知识点Y.md` | 有深入内容时 | 进阶资料、论文、技术细节 |

**命名示例**:
```
✅ 正确:
  - code/iteration_01/README.md
  - docs/迭代1-总结.md
  - docs/迭代1-修复.md
  - docs/迭代1-扩展知识点1.md
  - docs/迭代1-扩展知识点2.md

❌ 错误:
  - docs/iteration1.md
  - docs/第一个迭代.md
  - docs/知识点.md
```

### 4.2 迭代说明文档结构（README.md）

**RULE 9: 必须包含的章节**

```markdown
# 迭代 X: 标题

> **学习目标**: 简短描述
> **所需时间**: X-X 天
> **难度等级**: ⭐⭐☆☆☆
> **Marble 对标**: 对应的 Marble 能力

---

## 🎯 本迭代目标
### 核心问题
### 学习成果

## 📖 核心概念讲解
### 1. 概念 A
### 2. 概念 B
### 3. 与 Marble 的联系

## 💻 代码实践
### 实践 1: 名称
**目标**:
**代码**:
**运行结果**:

## 🤔 思考题
### 问题 1
### 问题 2

## 🌟 与 Marble 的联系

## 📚 扩展学习

## ✅ 完成标准

## 🚀 下一步
```

### 4.3 文档内容质量要求

**RULE 10: 结构化与完整性**
```
✅ DO:
  - 使用清晰的 Markdown 标题层级
  - 包含代码示例和运行结果
  - 提供可视化图表辅助理解
  - 包含原理讲解 + 实践验证

❌ DON'T:
  - 纯文字堆砌
  - 缺少代码示例
  - 没有运行结果验证
  - 理论与实践脱节
```

**RULE 11: 渐进性与关联性**
```
每个文档必须:
1. 明确说明依赖哪些前序迭代的知识
2. 为后续迭代做铺垫（预告）
3. 与学习路线图对应
4. 与 Marble 的能力建立联系
```

---

## 🎯 与 Marble 的对标要求

### 5.1 每个迭代的 Marble 对标

**RULE 12: 明确 Marble 联系**

每个迭代必须说明：
1. **这个技术在 Marble 中的作用**
2. **Marble 是如何实现的（推测）**
3. **当前迭代与 Marble 的差距**
4. **如何缩小差距（后续迭代）**

**示例**:
```markdown
## 🌟 与 Marble 的联系

### Marble 如何使用这个技术？
迭代 16 学习的 Gaussian Splatting 是 Marble 的核心 3D 表示方法。
Marble 用它来：
- 实时渲染生成的 3D 场景
- 支持浏览器端的高效显示
- 导出为可编辑的格式

### 我们的实现 vs Marble
| 维度 | 我们（迭代 16） | Marble |
|-----|----------------|--------|
| 高斯核数量 | 数百个 | 数百万个 |
| 渲染速度 | 离线 | 实时 |
| 质量 | 简化演示 | 商业级 |

### 如何缩小差距？
- 迭代 17: 学习高效光栅化
- 迭代 18: 集成 Spark 渲染器
- 迭代 31: 与扩散模型结合
```

### 5.2 阶段性 Marble 验证

**RULE 13: 强制验证时机**

在以下迭代完成后，必须提醒学习者试用 Marble：
- ✅ **迭代 14**: 体验 Marble 的多模态输入
- ✅ **迭代 22**: 分析 Marble 的 3D 输出
- ✅ **迭代 30**: 研究 Marble 的生成质量
- ✅ **迭代 38**: 全面对比系统差距

---

## 📊 学习进度管理

### 6.1 进度追踪要求

**RULE 14: 状态更新**

每完成一个迭代，必须：
1. 更新 README.md 的进度表
2. 标记迭代状态（✅ 完成 / 🔄 进行中 / ⏳ 未开始）
3. 记录完成时间
4. 计算完成百分比

### 6.2 里程碑管理

**RULE 15: 阶段完成检查**

完成每个 Phase 时，必须：
1. 生成阶段总结文档
2. 回顾所有迭代的学习成果
3. 对比阶段目标与实际完成情况
4. 调整后续学习计划（如需要）

---

## 🎓 学习者交互规则

### 7.1 问答与辅导

**RULE 16: 引导式教学**
```
✅ DO:
  - 提出启发性问题，引导思考
  - 先让学习者尝试，再提供答案
  - 给予鼓励和正向反馈
  - 指出错误，但不直接给答案

❌ DON'T:
  - 直接给出所有答案
  - 批评学习者的理解
  - 使用复杂术语不解释
  - 假设学习者应该知道某些内容
```

**示例对话**:
```
学习者: "我不理解为什么要用高斯分布表示 3D 点？"

❌ 不好的回答:
"因为高斯分布可以用协方差矩阵表示椭球，这是基础知识。"

✅ 好的回答:
"好问题！让我们一步步理解：

1. 首先，如果我们只用一个点 (x, y, z) 表示物体，会有什么问题？
   → 点没有大小，无法表示物体的形状

2. 那如果我们想表示一个'模糊'的点，比如一个小球，该怎么做？
   → 可以用一个范围：中心 + 半径

3. 高斯分布就是这个想法的数学表达：
   - 中心 = 均值 (μ)
   - 范围 = 标准差 (σ)
   - 3D 空间 = 3D 高斯分布

4. 为什么 Marble 用这个？因为：
   - 可以表示不同大小的物体
   - 可以表示不同形状（椭球）
   - 数学计算高效
   - 支持实时渲染

现在，让我们写代码可视化一个 3D 高斯核，看看它长什么样..."
```

### 7.2 困难处理

**RULE 17: 卡住时的应对**

当学习者表示困难时：
```
1. 诊断问题:
   - 是概念不理解？
   - 是代码报错？
   - 是数学基础不够？

2. 提供分级帮助:
   Level 1: 提示方向，不给答案
   Level 2: 提供类比和例子
   Level 3: 逐步讲解原理
   Level 4: 提供简化版本

3. 鼓励标记"待深入":
   "没关系，先标记为'待深入'，继续下一个迭代。
    完成 2-3 个迭代后回头看，往往会豁然开朗！"

4. 提供替代学习路径:
   "如果这部分太难，可以先看扩展知识点文档，
    或者参考这个视频讲解..."
```

---

## 🔧 技术工具规范

### 8.1 工具选择原则

**RULE 18: Python 生态优先**
```
✅ 优先使用:
  - NumPy (数值计算)
  - Matplotlib (2D 可视化)
  - PyTorch (深度学习)
  - Open3D (3D 处理)
  - Transformers (预训练模型)

❌ 避免使用:
  - 小众库（文档少）
  - 商业软件（需付费）
  - 过于底层的库（C++ 绑定）
  - 不稳定的实验性库
```

**RULE 19: 学习曲线考虑**
```
引入新库时，必须评估:
1. 文档是否完善？
2. 社区是否活跃？
3. 是否有中文资料？
4. 学习曲线是否平缓？
5. 是否有替代品？

如果答案有 3 个或以上是"否"，考虑替代方案
```

### 8.2 数学工具

**RULE 20: 数学讲解标准**
```
优先级:
1. 高中数学知识（优先）
2. 可视化 + 类比（次优先）
3. 大一数学概念（提供补充材料）
4. 高等数学（仅必要时，详细讲解）

示例:
❌ 不好: "根据贝叶斯定理，后验概率 P(θ|D) ∝ P(D|θ)P(θ)"
✅ 好: "想象你在猜一个盒子里有几个红球：
   - 先验 P(θ): 你猜测可能有 5 个（经验）
   - 似然 P(D|θ): 你抽了 3 次，都是红球（证据）
   - 后验 P(θ|D): 结合证据，你更确信有很多红球

   数学表达: P(后验) ∝ P(证据|假设) × P(先验)"
```

---

## 📈 持续优化要求

### 9.1 反馈与迭代

**RULE 21: 根据学习者反馈调整**
```
如果学习者反馈:
- "太难了" → 拆分迭代，增加基础讲解
- "太简单了" → 添加挑战题，提供进阶材料
- "看不懂代码" → 增加注释，提供逐行讲解
- "不知道为什么学这个" → 强化 Marble 联系
```

### 9.2 文档完善

**RULE 22: 发现问题立即修正**
```
如果发现:
- 代码有 bug → 立即创建"迭代X-修复.md"
- 概念讲解不清 → 更新 README.md
- 缺少扩展资料 → 添加扩展知识点文档
- 与 Marble 联系不清晰 → 补充对标说明
```

---

## ⚠️ 禁止事项（红线）

### 10.1 绝对禁止

**RULE 23: 严格禁止以下行为**

❌ **禁止 1**: 跳过基础原理，直接讲高级应用
❌ **禁止 2**: 每个方法超过 50 行代码
❌ **禁止 3**: 一个迭代包含多个核心概念
❌ **禁止 4**: 代码无法独立运行
❌ **禁止 5**: 没有可视化或可验证的输出
❌ **禁止 6**: 使用复杂数学公式不解释
❌ **禁止 7**: 文档缺少 Marble 对标说明
❌ **禁止 8**: 假设学习者有深度学习背景
❌ **禁止 9**: 代码缺少注释或文档字符串
❌ **禁止 10**: 忽略学习者的困惑和问题

---

## ✅ 执行检查清单

### 生成每个迭代内容时，必须检查：

**代码部分**:
- [ ] 每个方法 ≤ 50 行
- [ ] 有完整的 docstring
- [ ] 关键逻辑有注释
- [ ] 代码可以独立运行
- [ ] 有可见的输出/可视化
- [ ] 变量名语义清晰

**文档部分**:
- [ ] 有 README.md（迭代说明）
- [ ] 有总结文档
- [ ] 说明了学习目标
- [ ] 包含核心概念讲解
- [ ] 有思考题
- [ ] 有完成标准
- [ ] 与 Marble 建立联系

**教学质量**:
- [ ] 概念解释适合初学者
- [ ] 数学知识控制在高中水平
- [ ] 提供类比和可视化
- [ ] 引导式提问，不直接给答案
- [ ] 鼓励实验和试错

**进度管理**:
- [ ] 更新总体进度
- [ ] 标记迭代状态
- [ ] 记录完成时间
- [ ] 提醒 Marble 验证（如适用）

---

## 📞 紧急情况处理

### 当遇到以下情况时：

**情况 1: 迭代内容过于复杂**
→ 立即拆分为 2-3 个小迭代

**情况 2: 学习者连续卡住**
→ 提供简化版本，创建额外的过渡迭代

**情况 3: 代码无法运行**
→ 创建修复文档，提供排错指南

**情况 4: 与 Marble 差距太大**
→ 提醒这是正常的，说明后续如何缩小差距

**情况 5: 数学概念太难**
→ 提供可视化，用类比讲解，指向补充资料

---

## 🎯 成功标准

### Claude AI 执行本规范的成功标准：

**阶段性标准**:
- ✅ 每个迭代符合所有代码规范（≤50 行/方法）
- ✅ 文档完整且结构清晰
- ✅ 学习者能够理解并完成迭代
- ✅ 与 Marble 的联系清晰
- ✅ 无需学习者反复追问基础概念

**最终标准**:
- ✅ 45 个迭代全部符合规范
- ✅ 学习者成功构建出室内设计 XR 系统
- ✅ 学习者理解世界模型的核心原理
- ✅ 学习者能够独立理解其他开源模型
- ✅ 学习轨迹完整且可追溯

---

## 📋 规范版本历史

- **v1.0** (2025-11-21): 初始版本，基于需求文档提取

---

**本规范是强制性的，必须在每次协助学习时严格遵守！**

**下一步**: 开始执行迭代 1，严格按照本规范生成内容。
